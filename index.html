<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>数学研究部 | Math Club</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: white;
    }
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -10;
      pointer-events: none;
    }
  </style>
</head>
<body>

<script>
new p5(p => {
  const sideLength = 60;
  let triangles = [];
  let points = [];
  let walkers = [];
  let greenWalkers = [];
  let trailBuffer;

  // KPUMのパス設定
  const kpumPaths = [
    // K
    [{x: 100, y:100}, {x:100, y:300}, {x:100, y:200}, {x:150, y:100}, {x:100, y:200}, {x:150, y:300}],
    // P
    [{x:200, y:100}, {x:200, y:300}, {x:200, y:100}, {x:300, y:100}, {x:300, y:200}, {x:200, y:200}],
    // U
    [{x:350, y:100}, {x:350, y:300}, {x:450, y:300}, {x:450, y:100}],
    // M
    [{x:500, y:300}, {x:500, y:100}, {x:550, y:200}, {x:600, y:100}, {x:600, y:300}]
  ];

  p.setup = () => {
    const cnv = p.createCanvas(p.windowWidth, p.windowHeight);
    cnv.position(0, 0);
    p.background(255);

    trailBuffer = p.createGraphics(p.width, p.height);
    trailBuffer.clear();

    generateTriangleGrid();

    // 通常点のWalker
    for (let i = 0; i < 48; i++) {
      walkers.push(new Walker(p.random(points)));
    }

    // 緑点 (K, P, U, M)
    for (let path of kpumPaths) {
      greenWalkers.push(new GreenWalker(path));
    }
  };

  p.draw = () => {
    // 残像効果をかけたtrailBuffer
    trailBuffer.fill(255, 255, 255, 8);
    trailBuffer.noStroke();
    trailBuffer.rect(0, 0, p.width, p.height);

    // 三角タイル描画
    p.noFill();
    p.stroke(0, 30);
    for (let t of triangles) {
      p.beginShape();
      for (let pt of t) {
        p.vertex(pt.x, pt.y);
      }
      p.endShape(p.CLOSE);
    }

    // 黒点の描画
    for (let w of walkers) {
      w.update();
      w.display();
    }

    // 緑点の描画 (軌跡あり)
    trailBuffer.fill(0, 200, 0);
    for (let gw of greenWalkers) {
      gw.update();
      gw.display(trailBuffer);
    }

    // 最後にバッファを上から重ねる
    p.image(trailBuffer, 0, 0);
  };

  function generateTriangleGrid() {
    const h = sideLength * Math.sqrt(3) / 2;
    for (let y = 0; y < p.height + h; y += h) {
      for (let x = 0; x < p.width + sideLength; x += sideLength) {
        const xOffset = (Math.floor(y / h) % 2) * (sideLength / 2);
        const p1 = p.createVector(x + xOffset, y);
        const p2 = p.createVector(x + sideLength / 2 + xOffset, y + h);
        const p3 = p.createVector(x - sideLength / 2 + xOffset, y + h);
        triangles.push([p1, p2, p3]);
        points.push(p1, p2, p3);
      }
    }
  }

  class Walker {
    constructor(start) {
      this.current = start;
      this.next = p.random(points);
      this.t = 0;
      this.speed = p.random(0.003, 0.007);
    }

    update() {
      this.t += this.speed;
      if (this.t >= 1) {
        this.current = this.next;
        this.next = p.random(points);
        this.t = 0;
      }
    }

    display() {
      const x = p.lerp(this.current.x, this.next.x, this.t);
      const y = p.lerp(this.current.y, this.next.y, this.t);
      p.noStroke();
      p.fill(0);
      p.ellipse(x, y, 6, 6);
    }
  }

  class GreenWalker {
    constructor(path) {
      this.path = path;
      this.index = 0;
      this.t = 0;
      this.speed = 0.008; // やや遅め
      this.forward = true;
    }

    update() {
      this.t += this.speed;
      if (this.t >= 1) {
        this.t = 0;
        if (this.forward) {
          this.index++;
          if (this.index >= this.path.length - 1) {
            this.forward = false;
          }
        } else {
          this.index--;
          if (this.index <= 0) {
            this.forward = true;
          }
        }
      }
    }

    display(buffer) {
      const a = this.path[this.index];
      const b = this.path[this.forward ? this.index + 1 : this.index - 1];
      const x = p.lerp(a.x, b.x, this.t);
      const y = p.lerp(a.y, b.y, this.t);
      buffer.noStroke();
      buffer.ellipse(x, y, 8, 8);
    }
  }

  p.windowResized = () => {
    p.resizeCanvas(p.windowWidth, p.windowHeight);
    trailBuffer = p.createGraphics(p.width, p.height);
    trailBuffer.clear();
  };
});
</script>

</body>
</html>
